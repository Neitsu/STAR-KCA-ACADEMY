<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Star KCA Academy</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg: #0a0d15;
      --panel: #121a2b;
      --panel2: #1a2440;
      --text: #eef3ff;
      --muted: #9aa6c2;
      --line: #2d3d60;
      --accent: #8b5cf6;
      --accent2: #ec4899;
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at top, #1f2d4e 0%, #0d1425 45%, #070a12 100%);
    }
    .container { width: min(1160px, 92vw); margin: 0 auto; }
    header {
      position: sticky; top: 0; z-index: 30;
      backdrop-filter: blur(8px);
      background: rgba(10, 13, 21, .9);
      border-bottom: 1px solid var(--line);
    }
    .topbar { min-height: 68px; display: flex; align-items: center; justify-content: space-between; gap: .7rem; flex-wrap: wrap; padding: .8rem 0; }
    .brand h1 { margin: 0; font-size: 1.02rem; text-transform: uppercase; letter-spacing: .08em; }
    .brand p { margin: .2rem 0 0; color: var(--muted); font-size: .8rem; }
    nav { display: flex; gap: .5rem; flex-wrap: wrap; }
    .nav-link {
      text-decoration: none; color: var(--text); background: var(--panel);
      border: 1px solid var(--line); border-radius: 999px; padding: .42rem .74rem; font-size: .84rem;
    }
    .nav-link.active { background: linear-gradient(120deg, var(--accent), var(--accent2)); border-color: transparent; }
    main { padding: 1rem 0 2.6rem; }
    .page { display: none; }
    .page.active { display: block; }
    .card {
      background: linear-gradient(180deg, #19243d 0%, #111827 100%);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 1rem;
      margin-bottom: 1rem;
    }
    h2, h3 { margin: .2rem 0 .85rem; }
    .small { color: var(--muted); font-size: .82rem; }
    .filters { display: flex; flex-wrap: wrap; gap: .55rem; margin-bottom: .85rem; }
    input, select {
      border-radius: 10px; border: 1px solid var(--line);
      background: #0d1527; color: var(--text); padding: .52rem .7rem;
    }
    .contestants-grid { display: grid; gap: .8rem; grid-template-columns: repeat(auto-fill, minmax(178px, 1fr)); }
    .contestant-card {
      border: 1px solid var(--line); border-radius: 12px; overflow: hidden; cursor: pointer; background: #0d1526;
      transition: transform .12s ease;
    }
    .contestant-card:hover { transform: translateY(-2px); }
    .contestant-card img { width: 100%; height: 165px; object-fit: cover; display: block; }
    .contestant-card .body { padding: .68rem; }
    .pill { display: inline-block; margin-top: .32rem; padding: .16rem .52rem; border-radius: 999px; font-size: .72rem; border: 1px solid transparent; }
    .safe { background: rgba(34,197,94,.16); border-color: rgba(34,197,94,.45); }
    .nominee { background: rgba(245,158,11,.16); border-color: rgba(245,158,11,.42); }
    .saved_judges, .saved_public { background: rgba(59,130,246,.16); border-color: rgba(59,130,246,.42); }
    .eliminated { background: rgba(239,68,68,.16); border-color: rgba(239,68,68,.42); }
    .tbd { background: rgba(148,163,184,.16); border-color: rgba(148,163,184,.42); }
    .row { display: grid; grid-template-columns: 1fr; gap: 1rem; }
    @media (min-width: 840px) { .row.two { grid-template-columns: 280px 1fr; } }
    .profile-img { width: 100%; max-width: 260px; border-radius: 12px; border: 1px solid var(--line); }
    .btn { text-decoration: none; color: var(--text); border: 1px solid var(--line); background: var(--panel2); border-radius: 10px; padding: .42rem .7rem; display: inline-block; }
    .table-wrap { overflow: auto; }
    table { width: 100%; border-collapse: collapse; font-size: .88rem; }
    th, td { border-bottom: 1px solid var(--line); padding: .5rem .36rem; text-align: left; white-space: nowrap; }
    .chip { display: inline-block; border: 1px solid var(--line); border-radius: 999px; padding: .18rem .52rem; font-size: .74rem; background: rgba(99,102,241,.12); }
    .vote-row { margin-bottom: .72rem; }
    .bar { width: 100%; height: 12px; border: 1px solid var(--line); background: #091224; border-radius: 999px; overflow: hidden; }
    .bar > span { display: block; height: 100%; background: linear-gradient(90deg, var(--accent), var(--accent2)); }
  </style>
</head>
<body>
<header>
  <div class="container topbar">
    <div class="brand">
      <h1>Star KCA Academy</h1>
      <p>Contestants · Rankings · Votes</p>
    </div>
    <nav id="nav"></nav>
  </div>
</header>

<main class="container">
  <section id="contestants" class="page active"></section>
  <section id="profile" class="page"></section>
  <section id="rankings" class="page"></section>
  <section id="votes" class="page"></section>
</main>

<script>
const CONFIG = {
  SHEET_ID: "1wllhbdbdIJM3uTI-WnJFE5eJ8zb_scgik5k94Yegc1s",
  SHEETS: {
    contestants: "contestants",
    rounds: "rounds",
    submissions: "submissions",
    scores: "scores",
    judge_rankings: "judge_rankings",
    round_status: "round_status",
    votes_live: "votes_live"
  },
  REFRESH_MS: 30000
};

const ROUND_ORDER = ["PRERANK", "ROUND_1", "ROUND_2", "ROUND_3", "ROUND_4", "ROUND_5", "ROUND_6", "FINAL"];
const ROUND_LABELS = { PRERANK: "Prerank", ROUND_1: "R1", ROUND_2: "R2", ROUND_3: "R3", ROUND_4: "R4", ROUND_5: "R5", ROUND_6: "R6", FINAL: "Final" };
const CANDIDATE_NAMES = ["yza","hope","lea","megara","asli","chanel","heaven","manuee","hwa_young","mimi","eria","panida","kelsy","suhaa","johi","sun","kora","brahmini","katie","donghyun","lizy","kyo"];
const PRETTY = { yza:"Yza", hope:"Hope", lea:"Lea", megara:"Megara", asli:"Asli", chanel:"Chanel", heaven:"Heaven", manuee:"Manuee", hwa_young:"Hwa Young", mimi:"Mimi", eria:"Eria", panida:"Panida", kelsy:"Kelsy", suhaa:"Suhaa", johi:"Johi", sun:"Sun", kora:"Kora", brahmini:"Brahmini", katie:"Katie", donghyun:"Donghyun", lizy:"Lizy", kyo:"Kyo" };


function canonicalRoundId(value) {
  const raw = String(value || '').trim().toUpperCase().replace(/\s+/g, '_').replace(/-/g, '_');
  if (!raw) return '';
  if (raw in ROUND_LABELS) return raw;
  const m = raw.match(/^ROUND_?(\d+)$/);
  if (m) return `ROUND_${m[1]}`;
  if (raw === 'PRE_RANK' || raw === 'PRERANKING') return 'PRERANK';
  if (raw === 'FINALS') return 'FINAL';
  return raw;
}

const state = {
  data: { contestants: [], rounds: [], submissions: [], scores: [], judge_rankings: [], round_status: [], votes_live: [] },
  latestRound: "PRERANK",
  profileChart: null,
  rankingsChart: null,
  votesRound: "PRERANK",
  votesTimer: null
};

async function fetchSheetTab(sheetName) {
  if (!CONFIG.SHEET_ID || CONFIG.SHEET_ID.includes("PASTE")) throw new Error("No sheet id configured");
  const url = `https://docs.google.com/spreadsheets/d/${CONFIG.SHEET_ID}/gviz/tq?sheet=${encodeURIComponent(sheetName)}&tqx=out:json`;
  const res = await fetch(url);
  const text = await res.text();
  const payload = JSON.parse(text.substring(47, text.length - 2));
  const cols = payload.table.cols.map(c => c.label);
  return payload.table.rows.map(r => {
    const obj = {};
    cols.forEach((col, i) => obj[col] = r.c[i]?.v ?? "");
    return obj;
  });
}

function fallbackData() {
  return {
    contestants: CANDIDATE_NAMES.map((id) => ({
      id,
      name: PRETTY[id],
      photo_url: `assets/${id}.jpg`,
      country: "TBD",
      bio: "Bio to be filled.",
      instagram: "",
      pronouns: ""
    })),
    rounds: ROUND_ORDER.map(r => ({ round_id: r, round_name: ROUND_LABELS[r], start_date: "", end_date: "" })),
    submissions: [],
    scores: [],
    judge_rankings: [],
    round_status: [],
    votes_live: []
  };
}

async function loadData() {
  try {
    const entries = await Promise.all(Object.entries(CONFIG.SHEETS).map(async ([k, v]) => [k, await fetchSheetTab(v)]));
    state.data = Object.fromEntries(entries);
  } catch {
    state.data = fallbackData();
  }
}


function normalizeData() {
  state.data.round_status = Array.isArray(state.data.round_status) ? state.data.round_status : [];
  state.data.scores = Array.isArray(state.data.scores) ? state.data.scores : [];
  state.data.judge_rankings = Array.isArray(state.data.judge_rankings) ? state.data.judge_rankings : [];
  state.data.submissions = Array.isArray(state.data.submissions) ? state.data.submissions : [];
  state.data.votes_live = Array.isArray(state.data.votes_live) ? state.data.votes_live : [];

  const normId = (v) => String(v || '').trim().toLowerCase().replace(/\s+/g, '_');

  state.data.round_status = state.data.round_status.map(r => ({ ...r, round_id: canonicalRoundId(r.round_id), contestant_id: normId(r.contestant_id) }));
  state.data.scores = state.data.scores.map(r => ({ ...r, round_id: canonicalRoundId(r.round_id), contestant_id: normId(r.contestant_id) }));
  state.data.judge_rankings = state.data.judge_rankings.map(r => ({ ...r, round_id: canonicalRoundId(r.round_id), contestant_id: normId(r.contestant_id) }));
  state.data.submissions = state.data.submissions.map(r => ({ ...r, round_id: canonicalRoundId(r.round_id), contestant_id: normId(r.contestant_id) }));
  state.data.votes_live = state.data.votes_live.map(r => ({ ...r, round_id: canonicalRoundId(r.round_id), contestant_id: normId(r.contestant_id) }));
  const raw = Array.isArray(state.data.contestants) ? state.data.contestants : [];
  const byId = new Map();
  raw.forEach((c) => {
    const id = String(c.id || '').trim().toLowerCase().replace(/\s+/g, '_');
    if (!id) return;
    byId.set(id, {
      id,
      name: c.name || PRETTY[id] || id,
      photo_url: c.photo_url || `assets/${id}.jpg`,
      country: c.country || 'TBD',
      bio: c.bio || 'Bio TBD',
      instagram: c.instagram || '',
      pronouns: c.pronouns || ''
    });
  });
  if (!byId.size) {
    CANDIDATE_NAMES.forEach((id) => byId.set(id, {
      id,
      name: PRETTY[id] || id,
      photo_url: `assets/${id}.jpg`,
      country: 'TBD',
      bio: 'Bio TBD',
      instagram: '',
      pronouns: ''
    }));
  }
  state.data.contestants = [...byId.values()];
}


function setupNav() {
  const tabs = ["contestants", "rankings", "votes"];
  document.getElementById("nav").innerHTML = tabs.map(t => `<a class="nav-link" href="#${t}">${t[0].toUpperCase() + t.slice(1)}</a>`).join("");
}

function setPage(hash) {
  const target = hash.startsWith("#profile/") ? "profile" : (hash.replace("#", "") || "contestants");
  document.querySelectorAll(".page").forEach(p => p.classList.toggle("active", p.id === target));
  document.querySelectorAll(".nav-link").forEach(a => a.classList.toggle("active", a.getAttribute("href") === `#${target}`));
  if (target === "profile") renderProfile(hash.split("/")[1]);
}

function getContestantName(id) {
  return state.data.contestants.find(c => c.id === id)?.name || PRETTY[id] || id;
}

function getOfficialRankingByRound() {
  const result = {};
  ROUND_ORDER.forEach(r => result[r] = {});

  const officialRows = state.data.judge_rankings.filter(r => String(r.judge_name || "").toLowerCase() === "official");
  if (officialRows.length) {
    ROUND_ORDER.forEach(round => {
      const rows = officialRows.filter(r => r.round_id === round).map(r => ({ id: r.contestant_id, rank: Number(r.rank) })).filter(r => Number.isFinite(r.rank));
      rows.forEach(row => result[round][row.id] = row.rank);
    });
    return result;
  }

  ROUND_ORDER.forEach(round => {
    const rows = state.data.scores
      .filter(s => s.round_id === round)
      .map(s => ({ id: s.contestant_id, total: Number(s.total) }))
      .filter(s => Number.isFinite(s.total))
      .sort((a, b) => b.total - a.total);
    rows.forEach((row, idx) => result[round][row.id] = idx + 1);
  });

  return result;
}

function getLatestRound(officialByRound) {
  for (let i = ROUND_ORDER.length - 1; i >= 0; i--) {
    const round = ROUND_ORDER[i];
    const hasRanking = Object.keys(officialByRound[round] || {}).length > 0;
    const hasStatus = state.data.round_status.some(r => r.round_id === round);
    if (hasRanking || hasStatus) return round;
  }
  return "PRERANK";
}

function getStatus(roundId, contestantId) {
  return state.data.round_status.find(r => r.round_id === roundId && r.contestant_id === contestantId)?.status || "";
}

function statusLabel(status) {
  return status ? status.replace("_", " ") : "TBD";
}

function statusClass(status) {
  return status || "tbd";
}

function sortedContestants() {
  const officialByRound = getOfficialRankingByRound();
  const currentRanks = officialByRound[state.latestRound] || {};
  return [...state.data.contestants].sort((a, b) => {
    const aStatus = getStatus(state.latestRound, a.id);
    const bStatus = getStatus(state.latestRound, b.id);
    const aElim = aStatus === "eliminated" ? 1 : 0;
    const bElim = bStatus === "eliminated" ? 1 : 0;
    if (aElim !== bElim) return aElim - bElim;

    const ar = currentRanks[a.id];
    const br = currentRanks[b.id];
    if (Number.isFinite(ar) && Number.isFinite(br)) return ar - br;
    if (Number.isFinite(ar)) return -1;
    if (Number.isFinite(br)) return 1;
    return String(a.name || PRETTY[a.id] || a.id).localeCompare(String(b.name || PRETTY[b.id] || b.id));
  });
}

function renderContestants() {
  const root = document.getElementById("contestants");
  root.innerHTML = `
    <div class="card">
      <h2>Contestants</h2>
      <p class="small">Auto-updated from latest available official ranking/status round: <span class="chip">${ROUND_LABELS[state.latestRound]}</span></p>
      <div class="filters">
        <input id="searchContestant" placeholder="Search name..." />
        <select id="statusFilter">
          <option value="all">All status</option>
          <option value="safe">safe</option>
          <option value="nominee">nominee</option>
          <option value="saved_judges">saved judges</option>
          <option value="saved_public">saved public</option>
          <option value="eliminated">eliminated</option>
          <option value="tbd">TBD</option>
        </select>
      </div>
      <div id="contestantsGrid" class="contestants-grid"></div>
    </div>`;

  const draw = () => {
    const q = document.getElementById("searchContestant").value.toLowerCase().trim();
    const f = document.getElementById("statusFilter").value;
    const list = sortedContestants().filter(c => c.name.toLowerCase().includes(q)).filter(c => {
      const status = getStatus(state.latestRound, c.id);
      if (f === "all") return true;
      if (f === "tbd") return !status;
      return status === f;
    });

    document.getElementById("contestantsGrid").innerHTML = list.map(c => {
      const status = getStatus(state.latestRound, c.id);
      return `<article class="contestant-card" onclick="location.hash='#profile/${c.id}'">
        <img src="${c.photo_url}" alt="${c.name}" onerror="this.src='https://placehold.co/400x300?text=${c.name}'" />
        <div class="body"><strong>${c.name}</strong><div class="small">${c.country || "TBD"}</div><span class="pill ${statusClass(status)}">${statusLabel(status)}</span></div>
      </article>`;
    }).join("") || `<p class="small">No contestants found.</p>`;
  };

  document.getElementById("searchContestant").addEventListener("input", draw);
  document.getElementById("statusFilter").addEventListener("change", draw);
  draw();
}

function renderRankings() {
  const officialByRound = getOfficialRankingByRound();
  const contestants = sortedContestants();
  const root = document.getElementById("rankings");

  const rowsForNominations = {
    nominee: state.data.round_status.filter(r => r.round_id === state.latestRound && r.status === "nominee"),
    saved_judges: state.data.round_status.filter(r => r.round_id === state.latestRound && r.status === "saved_judges"),
    saved_public: state.data.round_status.filter(r => r.round_id === state.latestRound && r.status === "saved_public"),
    eliminated: state.data.round_status.filter(r => r.round_id === state.latestRound && r.status === "eliminated")
  };
  const nameList = (arr) => arr.map(r => getContestantName(r.contestant_id)).join(", ") || "TBD";

  root.innerHTML = `
    <div class="card">
      <h2>Rankings · Trajectory</h2>
      <p class="small">Table shows official rank evolution by round.</p>
      <div class="table-wrap">
        <table>
          <thead>
            <tr>
              <th>Rank</th>
              <th>Name</th>
              ${ROUND_ORDER.map(r => `<th><span class="chip">${ROUND_LABELS[r]}</span></th>`).join("")}
            </tr>
          </thead>
          <tbody>
            ${contestants.map((c, idx) => {
              const currentRank = officialByRound[state.latestRound][c.id];
              return `<tr>
                <td>${Number.isFinite(currentRank) ? currentRank : idx + 1}</td>
                <td>${c.name}</td>
                ${ROUND_ORDER.map(r => {
                  const val = officialByRound[r][c.id];
                  return `<td>${Number.isFinite(val) ? val : "—"}</td>`;
                }).join("")}
              </tr>`;
            }).join("")}
          </tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h3>Nominations (${ROUND_LABELS[state.latestRound]})</h3>
      <p><strong>Nominated:</strong> ${nameList(rowsForNominations.nominee)}</p>
      <p><strong>Saved by judges:</strong> ${nameList(rowsForNominations.saved_judges)}</p>
      <p><strong>Saved by public:</strong> ${nameList(rowsForNominations.saved_public)}</p>
      <p><strong>Eliminated:</strong> ${nameList(rowsForNominations.eliminated)}</p>
    </div>
    <div class="card">
      <h3>Global trajectory chart</h3>
      <p class="small">All contestants are shown. Lower rank is better (1 = top).</p>
      <canvas id="allContestantsChart" height="120"></canvas>
    </div>`;

  const datasets = contestants.map((c, idx) => ({
    label: c.name,
    data: ROUND_ORDER.map(r => officialByRound[r][c.id] ?? null),
    borderColor: `hsl(${(idx * 33) % 360} 82% 66%)`,
    backgroundColor: "transparent",
    borderWidth: 1.8,
    pointRadius: 1.8,
    tension: .2,
    spanGaps: true
  }));

  if (state.rankingsChart) state.rankingsChart.destroy();
  state.rankingsChart = new Chart(document.getElementById("allContestantsChart"), {
    type: "line",
    data: { labels: ROUND_ORDER.map(r => ROUND_LABELS[r]), datasets },
    options: {
      plugins: { legend: { labels: { color: "#eef3ff", boxWidth: 10, font: { size: 10 } } } },
      scales: {
        x: { ticks: { color: "#9aa6c2" } },
        y: { reverse: true, min: 1, max: Math.max(22, state.data.contestants.length), ticks: { color: "#9aa6c2", stepSize: 1 } }
      }
    }
  });
}

function renderProfile(contestantId) {
  const c = state.data.contestants.find(x => x.id === contestantId) || state.data.contestants[0];
  if (!c) return;

  const officialByRound = getOfficialRankingByRound();
  const scores = state.data.scores.filter(s => s.contestant_id === c.id);
  const submissions = state.data.submissions.filter(s => s.contestant_id === c.id);

  document.getElementById("profile").innerHTML = `
    <div class="card"><a class="btn" href="#contestants">← Back to contestants</a></div>
    <div class="card row two">
      <img class="profile-img" src="${c.photo_url}" alt="${c.name}" onerror="this.src='https://placehold.co/400x420?text=${c.name}'" />
      <div>
        <h2>${c.name}</h2>
        <p>${c.bio || "Bio TBD"}</p>
        <p class="small">Country: ${c.country || "TBD"} · Pronouns: ${c.pronouns || "TBD"} · Instagram: ${c.instagram || "TBD"}</p>
      </div>
    </div>
    <div class="card">
      <h3>Rounds overview</h3>
      <div class="table-wrap"><table>
      <thead><tr><th>Round</th><th>Official rank</th><th>Total score (if provided)</th><th>Status</th></tr></thead>
      <tbody>
      ${ROUND_ORDER.map(r => {
        const score = scores.find(s => s.round_id === r)?.total;
        const rank = officialByRound[r][c.id];
        const status = getStatus(r, c.id);
        return `<tr><td>${ROUND_LABELS[r]}</td><td>${Number.isFinite(rank) ? rank : "—"}</td><td>${score ?? "—"}</td><td>${statusLabel(status)}</td></tr>`;
      }).join("")}
      </tbody>
      </table></div>
    </div>
    <div class="card">
      <h3>Performances</h3>
      <div class="table-wrap"><table>
      <thead><tr><th>Round</th><th>Song</th><th>Links</th></tr></thead>
      <tbody>
      ${submissions.map(s => `<tr><td>${ROUND_LABELS[s.round_id] || s.round_id}</td><td>${s.song_title || s.group_song || "TBD"}</td><td>${s.youtube_url ? `<a target="_blank" href="${s.youtube_url}">YouTube</a>` : "—"}${s.bandlab_url ? ` · <a target="_blank" href="${s.bandlab_url}">BandLab</a>` : ""}</td></tr>`).join("") || `<tr><td colspan="3">No performance links yet.</td></tr>`}
      </tbody>
      </table></div>
    </div>
    <div class="card"><h3>Individual trajectory chart</h3><canvas id="profileChart" height="110"></canvas></div>`;

  if (state.profileChart) state.profileChart.destroy();
  state.profileChart = new Chart(document.getElementById("profileChart"), {
    type: "line",
    data: {
      labels: ROUND_ORDER.map(r => ROUND_LABELS[r]),
      datasets: [{
        label: `${c.name} official rank`,
        data: ROUND_ORDER.map(r => officialByRound[r][c.id] ?? null),
        borderColor: "#8b5cf6",
        backgroundColor: "rgba(139,92,246,.2)",
        tension: .25,
        spanGaps: true
      }]
    },
    options: {
      plugins: { legend: { labels: { color: "#eef3ff" } } },
      scales: {
        x: { ticks: { color: "#9aa6c2" } },
        y: { reverse: true, min: 1, max: Math.max(22, state.data.contestants.length), ticks: { color: "#9aa6c2", stepSize: 1 } }
      }
    }
  });
}

function renderVotes() {
  const root = document.getElementById("votes");
  const roundsWithVotes = ROUND_ORDER.filter(r => state.data.votes_live.some(v => v.round_id === r));
  if (!roundsWithVotes.includes(state.votesRound)) state.votesRound = roundsWithVotes[0] || state.latestRound;

  const nominees = state.data.round_status.filter(r => r.round_id === state.votesRound && r.status === "nominee").map(r => r.contestant_id);
  const targets = nominees.length ? nominees : [...new Set(state.data.votes_live.filter(v => v.round_id === state.votesRound).map(v => v.contestant_id))];
  const rows = targets.map(id => {
    const record = state.data.votes_live.find(v => v.round_id === state.votesRound && v.contestant_id === id);
    return { id, name: getContestantName(id), votes: Number(record?.votes_count || 0), updated: record?.last_updated || "-" };
  }).sort((a, b) => b.votes - a.votes);
  const totalVotes = rows.reduce((sum, r) => sum + r.votes, 0);

  root.innerHTML = `
    <div class="card">
      <h2>Votes</h2>
      <div class="filters">
        <select id="votesRoundSelect">${ROUND_ORDER.map(r => `<option value="${r}" ${r===state.votesRound?"selected":""}>${ROUND_LABELS[r]}</option>`).join("")}</select>
      </div>
      ${rows.length ? rows.map(r => {
        const pct = totalVotes > 0 ? (r.votes / totalVotes) * 100 : 0;
        return `<div class="vote-row"><div><strong>${r.name}</strong> — ${r.votes} votes (${pct.toFixed(1)}%)</div><div class="bar"><span style="width:${pct}%"></span></div></div>`;
      }).join("") : "<p>No vote data for this round yet.</p>"}
      <p class="small">Total votes: ${totalVotes} · Last refresh: ${new Date().toLocaleString("fr-FR")}</p>
    </div>`;

  document.getElementById("votesRoundSelect").addEventListener("change", (e) => {
    state.votesRound = e.target.value;
    renderVotes();
  });

  clearTimeout(state.votesTimer);
  state.votesTimer = setTimeout(async () => {
    await loadData();
    normalizeData();
    const officialByRound = getOfficialRankingByRound();
    state.latestRound = getLatestRound(officialByRound);
    renderContestants();
    renderRankings();
    renderVotes();
  }, CONFIG.REFRESH_MS);
}

async function boot() {
  setupNav();
  await loadData();
  normalizeData();
  const officialByRound = getOfficialRankingByRound();
  state.latestRound = getLatestRound(officialByRound);
  const roundsWithVotes = ROUND_ORDER.filter(r => state.data.votes_live.some(v => v.round_id === r));
  state.votesRound = roundsWithVotes[0] || state.latestRound;

  renderContestants();
  renderRankings();
  renderVotes();

  setPage(location.hash || "#contestants");
  window.addEventListener("hashchange", () => setPage(location.hash));
}

boot();
</script>
</body>
</html>
